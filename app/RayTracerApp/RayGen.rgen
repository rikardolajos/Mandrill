#version 460
#extension GL_EXT_ray_tracing : require

// Specialization constant should be generated from scene information
layout (constant_id = 0) const uint VERTEX_COUNT = 1;
layout (constant_id = 1) const uint INDEX_COUNT = 1;
layout (constant_id = 2) const uint MATERIAL_COUNT = 1;
layout (constant_id = 3) const uint TEXTURE_COUNT = 1;

layout(set = 0, binding = 0) uniform CameraUniforms {
    mat4 view;
    mat4 view_inv;
    mat4 proj;
    mat4 proj_inv;
} camera;

layout(set = 3, binding = 0) uniform accelerationStructureEXT scene;

struct Vertex {
    vec3 position;
    vec3 normal;
    vec2 texcoord;
    vec3 tangent;
    vec3 binormal;
};

layout(set = 3, binding = 1) readonly buffer VertexBuffer {
	Vertex vertices[VERTEX_COUNT];
} vertexBuffer;

layout(set = 3, binding = 2) readonly buffer IndexBuffer {
	uint indices[INDEX_COUNT];
} indexBuffer;

const uint DIFFUSE_TEXTURE_BIT = 1 << 0;
const uint SPECULAR_TEXTURE_BIT = 1 << 1;
const uint AMBIENT_TEXTURE_BIT = 1 << 2;
const uint EMISSION_TEXTURE_BIT = 1 << 3;
const uint NORMAL_TEXTURE_BIT = 1 << 4;

struct MaterialParams {
    vec3 diffuse;
    float shininess;
    vec3 specular;
    float indexOfRefraction;
    vec3 ambient;
    float opacity;
    vec3 emission;
    uint hasTexture;
};

struct Material {
    MaterialParams params;
    uint diffuseTextureIndex;
    uint specularTextureIndex;
    uint ambientTextureIndex;
    uint emissionTextureIndex;
    uint normalTextureIndex;
};

layout(set = 3, binding = 3) readonly buffer MaterialBuffer {
	Material materials[MATERIAL_COUNT];
} materialBuffer;

layout(set = 3, binding = 4) uniform sampler2D textures[TEXTURE_COUNT];

layout(set = 4, binding = 0, rgba8) uniform image2D image;

struct RayPayload {
    vec3 barycentricCoordinates;
    uint primitiveIndex;
    uint materialIndex;
};

layout(location = 0) rayPayloadEXT RayPayload rayPayload;

void main()
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = camera.view_inv * vec4(0.0, 0.0, 0.0, 1.0);
	vec4 target = camera.proj_inv * vec4(d.x, d.y, 1.0, 1.0);
	vec4 direction = camera.view_inv * vec4(normalize(target.xyz), 0.0);

	float tMin = 0.001;
	float tMax = 10000.0;

    rayPayload.barycentricCoordinates = vec3(0.0);
    rayPayload.materialIndex = 0;

    traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tMin, direction.xyz, tMax, 0);

    // Extract ray payload
    vec3 bary = rayPayload.barycentricCoordinates;
    uint primitiveIndex = rayPayload.primitiveIndex;
    Material material = materialBuffer.materials[rayPayload.materialIndex];

    // Get triangle vertices
    uint i0 = indexBuffer.indices[primitiveIndex * 3 + 0];
    uint i1 = indexBuffer.indices[primitiveIndex * 3 + 1];
    uint i2 = indexBuffer.indices[primitiveIndex * 3 + 2];
    Vertex v0 = vertexBuffer.vertices[i0];
    Vertex v1 = vertexBuffer.vertices[i1];
    Vertex v2 = vertexBuffer.vertices[i2];

    vec2 uv = v0.texcoord * bary.x + v1.texcoord * bary.y + v2.texcoord * bary.z;

    vec3 diffuseColor = material.params.diffuse;
    if ((material.params.hasTexture & DIFFUSE_TEXTURE_BIT) != 0) {
        diffuseColor = texture(textures[material.diffuseTextureIndex], uv).rgb;
    }

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(diffuseColor, 0.0));
}
